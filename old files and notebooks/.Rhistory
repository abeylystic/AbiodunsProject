dSoyb=diff(Soyb)
adf.test(dSoyb)
plot.ts(dSoyb, col="green" )
adf.test(Corn)
dCorn=diff(Corn)
adf.test(dCorn)
plot.ts(dCorn, col="blue" )
adf.test(Xrate)
dxrate=diff(Xrate)
adf.test(dxrate)
plot.ts(dxrate, col="brown" )
#testing for Lag
#install.packages("lmtest")
library("lmtest")
#install.packages("vars")
library("vars")
acf_dWTI<-acf(dxrate, lag.max=5)
pacf_dWTI<-pacf(dxrate, lag.max=5)
grangertest(dWTI~dxrate, order = 4)
grangertest(dCorn~dxrate, order=4)
grangertest(dSoyb~dxrate, order=4)
#priliminary analysis
ggplot(volatility, aes(x = ExchangeRate , y = soybeanPrice)) +
geom_point() +
labs(title = "Scatter Plot", x = "Exchange Rate", y = "Soybean Price")
ggplot(volatility, aes(x = ExchangeRate , y = cornPrice)) +
geom_point() +
labs(title = "Scatter Plot", x = "Exchange Rate", y = "Corn Price")
ggplot(volatility, aes(x = ExchangeRate , y = WTIPrice)) +
geom_point() +
labs(title = "Scatter Plot", x = "Exchange Rate", y = "Oil Price")
qqnorm(volatility$ExchangeRate, main = "Q-Q Plot of Exchange Rate",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "red")
qqnorm(volatility$soybeanPrice, main = "Q-Q Plot of Soybean Price",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "tomato")
qqnorm(volatility$cornPrice, main = "Q-Q Plot of Corn Price",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "blue")
qqnorm(volatility$WTIPrice, main = "Q-Q Plot of Oil Price",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "green")
#GARCH MODEL
#garch_m <- list(xchange = 'ExchangeRate',
#               WTI_data = 'WTIPrice',
#              corn_data = 'cornPrice',
#             soyb_data = 'soybeanPrice')
xchange_ts <- volatility$ExchangeRate
soyb_ts <- volatility$soybeanPrice
wti_ts <- volatility$WTIPrice
corn_ts <- volatility$cornPrice
# Combine the external regressors into a matrix
ext_reg <- cbind(soyb_ts, wti_ts, corn_ts)
# Specify the GARCH model with external regressors
garch_spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1), external.regressors = ext_reg),
mean.model = list(armaOrder = c(0,0), external.regressors = ext_reg))
# Fit the GARCH model
garch_fit <- ugarchfit(spec = garch_spec, data = xchange_ts)
garch_fit
plot(garch_fit)
#########################################################################
library(fGarch)
# Fit an sGARCH(1,1) model without a mean equation
garch_model <- garchFit(data = xchange_ts,
spec = ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
distribution.model = "sstd"),
solver.control = list(trace = FALSE))
garch_model1 <- garchFit(data = xchange_ts,
spec = garch_spec,
solver.control = list(trace = FALSE))
egarch_spec <- ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0)))
egarch_fit <- ugarchfit(spec = egarch_spec, data = xchange_ts)
# Print the summary of the EGARCH model fit
egarch_fit
methods(class = "uGARCHfit")
coef(garch_model)
# Fit the GARCH model
garch_fit <- ugarchfit(spec = garch_spec, data = xchange_ts)
garch_fit
garch_model
# Fit an sGARCH(1,1) model without a mean equation
garch_model <- garchFit(data = xchange_ts,
spec = ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
distribution.model = "sstd"),
solver.control = list(trace = FALSE))
garch_model
# Specify the GARCH model with external regressors
garch_spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1), external.regressors = ext_reg),
mean.model = list(armaOrder = c(0,0), external.regressors = ext_reg))
# Fit the GARCH model
garch_fit <- ugarchfit(spec = garch_spec, data = xchange_ts)
garch_fit
egarch_spec <- ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0)))
egarch_fit <- ugarchfit(spec = egarch_spec, data = xchange_ts)
# Print the summary of the EGARCH model fit
egarch_fit
adf.test(WTI)
plot.ts(dWTI, col="red" )
plot.ts(WTI)
plot.ts(dWTI, col="red" )
plot.ts(Soyb)
plot.ts(dSoyb, col="green" )
plot.ts(Corn)
plot.ts(dCorn, col="blue" )
plot.ts(Xrate)
plot.ts(dxrate, col="brown" )
par(mfrow=c(2,1))
plot.ts(WTI)
plot.ts(dWTI, col="red" )
par(mfrow=c(2,1))
plot.ts(WTI, main="WTI Time Series")
plot.ts(dWTI, col="red", main="Differentiated WTI Time Series")
plot.ts(WTI, main="WTI and Differentiated WTI Time Series", col="blue")
lines(dWTI, col="red")
legend("topright", legend=c("WTI", "Differentiated WTI"), col=c("blue", "red"), lty=1)
par(mfrow=c(2,1))
plot.ts(WTI, main="WTI Time Series")
plot.ts(dWTI, col="red", main="Differentiated WTI Time Series")
par(mfrow=c(2,1))
plot.ts(WTI, main="Oil Futures Time Series")
plot.ts(dWTI, col="red", main="Differentiated Oil Futures Time Series")
par(mfrow=c(2,1))
plot.ts(WTI, col = "red", main="Oil Futures Time Series")
plot.ts(dWTI, col="red", main="Differentiated Oil Futures Time Series")
par(mfrow=c(2,1))
plot.ts(Soyb, col="green", main="Soybean Futures")
plot.ts(dSoyb, col="green", main="Differentiated Soybean Futures" )
par(mfrow=c(2,1))
plot.ts(Corn, col="blue", main="Corn Futures")
plot.ts(dCorn, col="blue", main="Differentiated Corn Futures")
par(mfrow=c(2,1))
plot.ts(Xrate, col="brown", main="Exchange rate")
plot.ts(dxrate, col="brown", main="Differenced Exchange rate")
#priliminary analysis
ggplot(volatility, aes(x = ExchangeRate , y = soybeanPrice)) +
geom_point() +
labs(title = "Scatter Plot", x = "Exchange Rate", y = "Soybean Price")
qqnorm(volatility$ExchangeRate, main = "Q-Q Plot of Exchange Rate",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "red")
qqnorm(volatility$soybeanPrice, main = "Q-Q Plot of Soybean Price",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "tomato")
qqnorm(volatility$cornPrice, main = "Q-Q Plot of Corn Price",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "blue")
qqnorm(volatility$WTIPrice, main = "Q-Q Plot of Oil Price",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "green")
xchange_ts <- volatility$dWTI
dWTI
ext_reg <- cbind(dWTI, dCorn, dSoyb)
xchange_ts <- dxrate
# Specify the GARCH model with external regressors
garch_spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1), external.regressors = ext_reg),
mean.model = list(armaOrder = c(0,0), external.regressors = ext_reg))
# Fit the GARCH model
garch_fit <- ugarchfit(spec = garch_spec, data = xchange_ts)
garch_fit
Gprice <- ts(volatility$GoldPrice,start=c(1), end= c(709), frequency =1)
adf.test(GoldPrice)
adf.test(Gprice)
dgprice=diff(Gprice)
adf.test(dgprice)
par(mfrow=c(2,1))
plot.ts(Gprice, col="brown", main="Exchange rate")
plot.ts(dgprice, col="brown", main="Differenced Exchange rate")
Wnews <- ts(volatility$WARNews,start=c(1), end= c(709), frequency =1)
adf.test(Gprice)
dgprice=diff(Gprice)
adf.test(dgprice)
par(mfrow=c(2,1))
plot.ts(Gprice, col="brown", main="Gold Futures")
plot.ts(dgprice, col="brown", main="Differenced Gold Futures")
adf.test(Wnews)
dwnews=diff(Wnews)
adf.test(dwnews)
par(mfrow=c(2,1))
plot.ts(Wnews, col="brown", main="War News")
plot.ts(dwnews, col="brown", main="Differenced War News")
ext_reg <- cbind(dWTI, dCorn, dSoyb, dgprice, dwnews)
xchange_ts <- dxrate
# Specify the GARCH model with external regressors
garch_spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1), external.regressors = ext_reg),
mean.model = list(armaOrder = c(0,0), external.regressors = ext_reg))
# Fit the GARCH model
garch_fit <- ugarchfit(spec = garch_spec, data = xchange_ts)
garch_fit
plot(garch_fit)
coef(garch_fit)
methods(class = "uGARCHfit")
getspec(garch_fit)
#getspec(garch_fit)
gof(garch_fit)
infocriteria(garch_fit)
likelihood(garch_fit)
newsimpact(garch_fit)
nyblom(garch_fit)
persistence(garch_fit)
pit(garch_fit)
pit(garch_fit)
quantile(garch_fit)
reduce(garch_fit)
show(garch_fit)
sigma(garch_fit)
signbias(garch_fit)
ugarchboot(garch_fit)
ugarchdistribution(garch_fit)
ugarchforecast(garch_fit)
ugarchsim(garch_fit)
uncmean(garch_fit)
uncvariance(garch_fit)
vcov(garch_fit)
# Fit an sGARCH(1,1) model without a mean equation
garch_model <- garchFit(data = xchange_ts,
spec = ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
distribution.model = "sstd"),
solver.control = list(trace = FALSE))
garch_model
coef(garch_model)
# Forecast future volatility
garch_forecast <- ugarchforecast(garch_fit, n.ahead = 10)
# Print the forecast
print(garch_forecast)
ugarchforecast(garch_fit)
dev.off()
#priliminary analysis
ggplot(volatility, aes(x = ExchangeRate , y = soybeanPrice)) +
geom_point() +
labs(title = "Scatter Plot", x = "Exchange Rate", y = "Soybean Price")
ggplot(volatility, aes(x = ExchangeRate , y = cornPrice)) +
geom_point() +
labs(title = "Scatter Plot", x = "Exchange Rate", y = "Corn Price")
ggplot(volatility, aes(x = ExchangeRate , y = WTIPrice)) +
geom_point() +
labs(title = "Scatter Plot", x = "Exchange Rate", y = "Oil Price")
qqnorm(volatility$ExchangeRate, main = "Q-Q Plot of Exchange Rate",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "red")
qqnorm(volatility$soybeanPrice, main = "Q-Q Plot of Soybean Price",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "tomato")
qqnorm(volatility$cornPrice, main = "Q-Q Plot of Corn Price",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "blue")
qqnorm(Xrate, main = "Q-Q Plot of Exchange Rate",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "red")
qqnorm(dxrate, main = "Q-Q Plot of Exchange Rate",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "red")
qqnorm(volatility$cornPrice, main = "Q-Q Plot of Corn Price",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "blue")
qqnorm(Corn, main = "Q-Q Plot of Corn Price",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "blue")
qqnorm(Corn, main = "Q-Q Plot of Corn Price",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "blue")
qqnorm(dCorn, main = "Q-Q Plot of Corn Price",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", col = "blue")
library(ccgarch)
install.packages("ccgarch")
R.version.string
R.version.string
# Define the URL for the latest RStudio macOS installer
url <- "https://download1.rstudio.org/desktop/macos/RStudio-latest.dmg"
# Define the path where the installer will be saved
installer_path <- "/tmp/RStudio-latest.dmg"
# Download the installer
download.file(url, destfile = installer_path, mode = "wb")
R.version.string
R.version.string
garch_model <- garchFit(data = xchange_ts,
spec = ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0, 0))),
solver.control = list(trace = FALSE))
garch_model
garch_model <- garchFit(data = xchange_ts,
spec = ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder = c(1, 1))),
solver.control = list(trace = FALSE))
xchange_ts
# Extract coefficients, standard errors, and p-values
coefficients <- coef(egarch_fit)
se <- sqrt(diag(egarch_fit@vcov))
# Extract coefficients and standard errors
coefficients <- coef(egarch_fit)
se <- sigma(egarch_fit)
# Calculate p-values
pvalues <- 2 * (1 - pnorm(abs(coefficients / se)))
# Extract coefficients and standard errors
coefficients <- coef(egarch_fit)
se <- sigma(egarch_fit)
# Calculate p-values
pvalues <- 2 * (1 - pnorm(abs(coefficients / se)))
# Combine into a data frame
results <- data.frame(coef = coefficients, se = se, pvalue = pvalues)
# Extract coefficients and calculate standard errors
coefficients <- coef(egarch_fit)
variance_covariance <- vcov(egarch_fit)
se <- sqrt(diag(variance_covariance))
# Calculate p-values
pvalues <- 2 * (1 - pnorm(abs(coefficients / se)))
# Combine into a data frame
results <- data.frame(coef = coefficients, se = se, pvalue = pvalues)
# Print the results
print(results)
# Print the summary of the EGARCH model fit
egarch_fit
egarch_spec <- ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0)), external.regressors = ext_reg)
egarch_spec <- ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0))), external.regressors = ext_reg)
egarch_spec <- ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0)), external.regressors = ext_reg)
egarch_spec <- ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0)),
external.regressors = ext_reg)
egarch_spec <- ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0)),
xreg = ext_reg)
egarch_spec <- ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0), xreg = ext_reg))
egarch_spec <- ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0),
external.regressors= ext_reg))
egarch_fit <- ugarchfit(spec = egarch_spec, data = xchange_ts)
# Print the summary of the EGARCH model fit
egarch_fit
setwd("/Users/abiodun.idowu/Library/CloudStorage/OneDrive-NorthDakotaUniversitySystem/Desktop/PhD/BEA project/notebook_to_start")
library(rgl)
library(dplyr)
library(tidyr)
library(kml3d)
library(kml)
# ai_data = rates, start with all variables
##################################################################################################################
data <- read.csv("nominal.csv")
# ai_data = rates, start with all variables
##################################################################################################################
data <- read.csv("nominal.csv")
# ai_data = rates, start with all variables
##################################################################################################################
data <- read.csv("nominal.csv")
complete_combinations <- expand.grid(FIPS_y = unique(data$FIPS_y),
TimePeriod = unique(data$TimePeriod))
# Step 2: Create a new data frame with complete combinations
new_data <- complete_combinations
# Step 3: Left join your original data to the new data frame, filling in missing values with NA
final_data <- new_data %>%
left_join(data, by = c("FIPS_y", "TimePeriod"))
data1 <- final_data
# Pivot the data from wide to long format
df_cl <- pivot_wider(
data = data1,
id_cols = FIPS_y,
names_from = TimePeriod,
values_from = -FIPS_y,  # Select all columns starting from the third column
names_prefix = ""
)
df_cl <- df_cl[, -c(2:21)]
idAll <- as.character(unique(df_cl$FIPS_y))
View(df_cl)
cld_data <- clusterLongData3d(df_cl, idAll = idAll, timeInData= list(x=c(2:21),
y=c(22:41),
z=c(42:61),
a=c(62:81),
b=c(82:101),
c=c(102:121)),
varNames= c("Agri","Mini", "Util",
"M4_y", "M4I", "unem"))
kml3d(cld_data, 2:6, nbRedrawing = 20, toPlot = 'criterion')
# Get clusters and store them in dataframe
df_cl$clusters <- getClusters(cld_data, nbCluster = 4)
# Export the data
write.csv(df_cl, file='nominal_kml3d.csv', row.names=FALSE)
# Next remove total gdp
################################################################################
data2 <- read.csv("diff_nominal.csv")
complete_combinations <- expand.grid(FIPS_y = unique(data2$FIPS_y),
TimePeriod = unique(data2$TimePeriod))
# Step 2: Create a new data frame with complete combinations
new_data <- complete_combinations
# Step 3: Left join your original data to the new data frame, filling in missing values with NA
final_data <- new_data %>%
left_join(data2, by = c("FIPS_y", "TimePeriod"))
data2 <- final_data
data1 <- final_data
# Pivot the data from wide to long format
df_cl <- pivot_wider(
data = data1,
id_cols = FIPS_y,
names_from = TimePeriod,
values_from = -FIPS_y,  # Select all columns starting from the third column
names_prefix = ""
)
df_cl <- df_cl[, -c(2:21)]
idAll <- as.character(unique(df_cl$FIPS_y))
View(df_cl)
cld_data <- clusterLongData3d(df_cl, idAll = idAll, timeInData= list(x=c(2:21),
y=c(22:41),
z=c(42:61),
a=c(62:81),
b=c(82:101),
c=c(102:121)),
varNames= c("Agri","Mini", "Util",
"M4_y", "M4I", "unem"))
kml3d(cld_data, 2:6, nbRedrawing = 20, toPlot = 'criterion')
# Get clusters and store them in dataframe
df_cl$clusters <- getClusters(cld_data, nbCluster = 4)
# Export the data
write.csv(df_cl, file='diff_nominal_kml3d.csv', row.names=FALSE)
# Next remove total gdp and neighbors gdp
################################################################################
data3 <- read.csv("real.csv")
complete_combinations <- expand.grid(FIPS_y = unique(data3$FIPS_y),
TimePeriod = unique(data3$TimePeriod))
# Step 2: Create a new data frame with complete combinations
new_data <- complete_combinations
# Step 3: Left join your original data to the new data frame, filling in missing values with NA
final_data <- new_data %>%
left_join(data3, by = c("FIPS_y", "TimePeriod"))
data1 <- final_data
# Pivot the data from wide to long format
df_cl <- pivot_wider(
data = data1,
id_cols = FIPS_y,
names_from = TimePeriod,
values_from = -FIPS_y,  # Select all columns starting from the third column
names_prefix = ""
)
df_cl <- df_cl[, -c(2:21)]
idAll <- as.character(unique(df_cl$FIPS_y))
cld_data <- clusterLongData3d(df_cl, idAll = idAll, timeInData= list(x=c(2:21),
y=c(22:41),
z=c(42:61),
a=c(62:81),
b=c(82:101),
c=c(102:121)),
varNames= c("Agri","Mini", "Util",
"M4_y", "M4I", "unem"))
kml3d(cld_data, 2:6, nbRedrawing = 20, toPlot = 'criterion')
# Get clusters and store them in dataframe
df_cl$clusters <- getClusters(cld_data, nbCluster = 4)
# Export the data
write.csv(df_cl, file='real_kml3d.csv', row.names=FALSE)
data3 <- read.csv("diff_real.csv")
data4 <- read.csv("diff_real.csv")
complete_combinations <- expand.grid(FIPS_y = unique(data4$FIPS_y),
TimePeriod = unique(data4$TimePeriod))
# Step 2: Create a new data frame with complete combinations
new_data <- complete_combinations
# Step 3: Left join your original data to the new data frame, filling in missing values with NA
final_data <- new_data %>%
left_join(data4, by = c("FIPS_y", "TimePeriod"))
data1 <- final_data
# Pivot the data from wide to long format
df_cl <- pivot_wider(
data = data1,
id_cols = FIPS_y,
names_from = TimePeriod,
values_from = -FIPS_y,  # Select all columns starting from the third column
names_prefix = ""
)
df_cl <- df_cl[, -c(2:21)]
idAll <- as.character(unique(df_cl$FIPS_y))
cld_data <- clusterLongData3d(df_cl, idAll = idAll, timeInData= list(x=c(2:21),
y=c(22:41),
z=c(42:61),
a=c(62:81),
b=c(82:101),
c=c(102:121)),
varNames= c("Agri","Mini", "Util",
"M4_y", "M4I", "unem"))
kml3d(cld_data, 2:6, nbRedrawing = 20, toPlot = 'criterion')
# Get clusters and store them in dataframe
df_cl$clusters <- getClusters(cld_data, nbCluster = 4)
# Export the data
write.csv(df_cl, file='diff_real_kml3d.csv', row.names=FALSE)
# 3.7
Arg(0.6+0.7i)
Mod(0.6+0.7i)
ARMAacf((ar=c(1.6, 0.64)), lag.max=10)
ARMAacf((ar=c(-0.4, -0.45)), lag.max=10)
ARMAacf((ar=c(-1.2, 0.85)), lag.max=10)
plot(0:10, ARMAacf(ar=c(1.6, 0.64), lag.max=10),
type="h", xlab="Lag", ylab="ACF", main="True ACF")
abline(h=0)
plot(0:10, ARMAacf(ar=c(-0.4, -0.45), lag.max=10),
type="h", xlab="Lag", ylab="ACF", main="True ACF")
abline(h=0)
plot(0:10, ARMAacf(ar=c(1.6, 0.64), lag.max=10),
type="h", xlab="Lag", ylab="ACF", main="True ACF")
abline(h=0)
plot(0:10, ARMAacf(ar=c(-0.4, -0.45), lag.max=10),
type="h", xlab="Lag", ylab="ACF", main="True ACF")
abline(h=0)
plot(0:10, ARMAacf(ar=c(-1.2, 0.85), lag.max=10),
type="h", xlab="Lag", ylab="ACF", main="True ACF")
abline(h=0)
ar = arima.sim(list(order=c(1,0,0), ar=0.6), n=100)
ma = arima.sim(list(order=c(0,0,1), ma=0.9), n=100)
arma = arima.sim(list(order=c(1,0,1), ar=0.6, ma=0.9), n=100)
acf(ar)
acf(ar, main='ACF for AR(1)')
par(mfrow=c(3,1))
acf(ar, main='ACF for AR(1)')
acf(ma, main='ACF for MA(1)')
acf(arma, main='ACF for ARMA(1,1)')
pacf(ar)
pacf(ar, main='PACF for AR(1)')
pacf(ma, main='PACF for MA(1)')
pacf(arma, main='PACF for ARMA(1,1)')
dev.off()
par(mfrow=c(3,1))
pacf(ar, main='PACF for AR(1)')
pacf(ma, main='PACF for MA(1)')
pacf(arma, main='PACF for ARMA(1,1)')
acf(ar, lag.max=10, main='ACF for AR(1)')
acf(ar, main='ACF for AR(1)')
acf2(ar, main='ACF for AR(1)')
acf2AR(ar, main='ACF for AR(1)')
acf(ar, main='ACF for AR(1)')
